#!/usr/bin/env ruby
require "erb"
require "uri"
require "net/http"
require "json"
require "ostruct"
require "set"
require "time"
require "yaml"

module Tty
  module_function

  def red;    bold 31; end
  def green;  bold 32; end
  def yellow; bold 33; end
  def blue;   bold 34; end
  def purple; bold 35; end
  def cyan;   bold 36; end
  def grey;   bold 37; end

  def reset; escape 0; end

  def bold(n = 39)
    escape "1;#{n}"
  end

  def underline
    escape "4;39"
  end

  def escape(n)
    "\e[#{n}m" if STDOUT.tty?
  end
end

CircleCI = Struct.new(:repo) do
  HTML_URL_TEMPLATE = "https://circleci.com/gh/%{repo}/tree/%{branch}".freeze
  PARAM = /%\{([a-z_]+)\}/

  def html_url(branch:)
    interpolate(HTML_URL_TEMPLATE, branch: branch)
  end

  def branch_builds(branch:, limit: 5, **params)
    get("project/github/%{repo}/tree/%{branch}", branch: branch, limit: limit, **params) do |response|
      response.map {|data| Build.new(data, detail: :commit_message) }
    end
  end

  def all_builds
    get("project/github/%{repo}", limit: 15) do |response|
      response.map {|data| Build.new(data, detail: :branch) }
    end
  end

  def failing_test_files(branch: nil, build_num: nil)
    with_build(url: "project/github/%{repo}/%{build_num}/tests", branch: branch, build_num: build_num, default: []) do |response|
      response[:tests].map {|data| TestResult.new(data) }
    end.select(&:failed?).map(&:file).uniq.sort
  end

  def failing_tests(branch: nil, build_num: nil)
    with_build(url: "project/github/%{repo}/%{build_num}", branch: branch, build_num: build_num, default: []) do |response|
      response.fetch(:steps).each_with_object(SortedSet.new) do |step, results|
        step.fetch(:actions, []).each do |action|
          next unless action[:bash_command] =~ /rspec/
          next unless action[:status] == "failed"
          next unless action[:has_output]

          get(action[:output_url]) do |response|
            stdout = response.find {|output| output[:type] == "out" } or raise "No stdout output found"

            results.merge RSpecOutput.new(stdout.fetch :message).tests
          end
        end
      end
    end
  end

  private

  def with_build(url:, branch: nil, build_num: nil, default: nil, &block)
    if branch
      with_last_failing_build(branch: branch, default: default) do |latest_build|
        get(url, build_num: latest_build.num, &block)
      end
    elsif build_num
      get(url, build_num: build_num, &block)
    end
  end

  def with_last_failing_build(branch:, default:, **params)
    latest_build = branch_builds(**params, branch: branch, limit: 1, filter: 'failed').first

    if latest_build
      yield(latest_build)
    else
      default
    end
  end

  def get(path, **params)
    url = path.start_with?("http") ? URI.parse(path) : build_url(path, params)
    response = Net::HTTP.get_response(url)
    response.value # raises error for non-2xx statuses
    yield JSON.parse(response.body, symbolize_names: true)
  end

  def build_url(path, **params)
    URI::HTTPS.build(
      host: "circleci.com",
      path: interpolate("/api/v1.1/#{path}", params),
      query: URI.encode_www_form(params.merge "circle-token" => config["circleci"])
    )
  end

  def interpolate(template, **params)
    params[:repo] = repo
    params[:branch] = ERB::Util.url_encode(params[:branch]) if params[:branch]

    template.gsub(PARAM) do
      key = Regexp.last_match[1]
      params.delete(key.to_sym) || params.delete(key) || raise(KeyError, "#{key.inspect} not provided")
    end
  end

  def config
    @config ||= begin
      config_dir = ENV.fetch("XDG_CONFIG_HOME") { File.join(ENV["HOME"], ".config") }

      YAML.load_file File.join(config_dir, "git-ci", "credentials.yml")
    end
  end

  class JSONStruct
    attr_reader :data

    def self.accessors(*keys)
      if keys.any?
        @accessors = keys
        attr_reader *keys
      else
        @accessors ||= []
      end
    end

    def initialize(data)
      @data = data

      self.class.accessors.each do |key|
        instance_variable_set("@#{key}", data[key])
      end
    end
  end

  class Build < JSONStruct
    accessors :build_num, :status, :subject, :branch, :vcs_revision, :build_time_millis, :start_time

    alias_method :num, :build_num

    def initialize(data, detail: :commit_message)
      @detail = detail

      super(data)
    end

    def status
      case @status
      when "fixed"    then "success"
      when "canceled" then "cancelled"
      when "not_run"  then "skipped"
      else @status
      end
    end

    def status_colour
      case status
      when "success" then Tty.green
      when "running" then Tty.cyan
      when "failed" then Tty.red
      when "queued" then Tty.purple
      else Tty.grey
      end
    end

    def time
      return "-- --" unless build_time_millis || start_time

      seconds = if build_time_millis
        build_time_millis / 1000
      elsif start_time
        Time.now.utc - Time.parse(start_time)
      end

      format "%2d'%02d", *seconds.divmod(60)
    end

    def sha
      vcs_revision[0..6]
    end

    def commit_message
      return "" unless subject

      subject[0..77].tap do |str|
        str << "..." if str != subject
      end
    end

    def detail
      case @detail
      when :commit_message then commit_message
      when :branch then branch
      end
    end

    def to_ary
      [
        coloured(status),
        coloured("##{num}"),
        "#{Tty.yellow}#{sha}#{Tty.reset}",
        "#{Tty.grey}#{detail}#{Tty.reset}",
        coloured(time)
      ].map(&:to_s)
    end

    private

    def coloured(text)
      "#{status_colour}#{text}#{Tty.reset}"
    end
  end

  class TestResult < JSONStruct
    accessors :classname, :file, :name, :result, :run_time

    def failed?
      result == "failure"
    end
  end

  RSpecOutput = Struct.new(:message) do
    ANSI_CODE = /\e\[([;\d]+)?m/m

    def tests
      commands = message.to_s
        .split(/\r\n\r\nFailed examples:\r\n\r\n/).last
        .split(/\r\n\r\nRandomized with seed/).first

      commands.each_line.map do |command|
        strip_ansi(command).strip.sub("rspec ./", "")
      end
    end

    private

    def strip_ansi(string)
      string.gsub(ANSI_CODE, "")
    end
  end
end

def ci
  if File.directory? ".circleci"
    repo = git("remote get-url origin").split(/:/).last.gsub(/\.git/, %{})

    CircleCI.new(repo)
  else
    quit "Unable to determine CI service"
  end
end

def table(rows)
  columns = rows.transpose

  columns.map! do |column|
    max_length = column.max_by(&:length).length
    column.map {|cell| cell.ljust(max_length) }
  end

  puts columns.transpose.map {|row| row.join("    ") }
end

def quit(message)
  warn message
  exit 1
end

def git(command)
  `git #{command}`.chomp
end


args = ARGV.dup
args.unshift("open") if args.none?

command = args.first

# common setup
branch = ARGV[1] || git("symbolic-ref --short HEAD")

case command
when "open", "browse"
  system "open #{ci.html_url branch: branch}"
when "status"
  if %w[--all -a].include? branch
    table ci.all_builds
  else
    table ci.branch_builds(branch: branch)
  end
when "failing-test-files"
  if branch =~ /^--build.(\d+)$/
    puts ci.failing_test_files(build_num: Regexp.last_match[1])
  else
    puts ci.failing_test_files(branch: branch)
  end
when "failing-tests"
  if branch =~ /^--build.(\d+)$/
    puts ci.failing_tests(build_num: Regexp.last_match[1]).to_a
  else
    puts ci.failing_tests(branch: branch).to_a
  end
else
  quit "Unknown command: #{command}"
end
